# Contributing to kev-bot API

## Running migrations locally

1. Make sure you have built the `kevbot-tools` docker image
2. Run the following command from root of project

```sh
docker run --rm --env-file .env -v ./db/migration:/tools/db/migration_manager/migration kevbot-tools bash -c "cd /tools/db/migration_manager && /opt/migration_manager/.venv/bin/python migration_manager migrate -v latest --schema-dir ./migration/schema_change_scripts --supplemental-dirs ./migration/supplemental_scripts ./migration/sensitive_supplemental_scripts"
```

## Docker structure

needs to be updated

```text
project-root/
│
├── .devcontainer/
│   ├── deploy/
│   │   └── devcontainer.json
│   ├── api/
│   │   └── devcontainer.json
│   ├── bot/
│   │   └── devcontainer.json
│   ├── frontend/
│   │   └── devcontainer.json
│   └── docker-compose.dev.yml
│
├── api/
│   └── Dockerfile
├── db/
│   ├── mysql/
│   │   └── scripts/
│   └── Dockerfile
├── bot/
│   └── Dockerfile
├── frontend/
│   └── Dockerfile
├── deploy/
│   └── Dockerfile
├── docker-compose.prod.yml

```

## Development Environment Setup

Install docker.

### Environment File

Create a `.env` at the root directory of the project. It can be convenient for this file to actually be a symbolic link to another env file like `dev.env` or `staging.env`. A symbolic link can be created with the following:

```sh
ln -s dev.env .env
```

## Containers

### Tools Container

Note the development docker compose file mounts the root of KevBot to `src-dev`, that way you can do live development there if needed, but there is another directory called `src` which is just a copy of `/tools/` and `db/migration/`.

### Starting containers

```sh
docker compose --env-file .env -f docker-compose.dev.yml up [-d]
```

### Stopping containers

```sh
docker compose -f docker-compose.dev.yml down
```

### Dev Containers

Make sure to install the [VS Code Dev Containers Extension](https://code.visualstudio.com/docs/devcontainers/containers).

Run VS Code command `Dev Containers: Attach to Running Containers...` to easily run code or even development within the docker environment.

## Old Content

Here is a guide for contributing to kev-bot api

- [Project Workflow](#project-workflow)

## <a name="project-workflow"></a> Project Workflow

This project will utilize the following tools/ideas:

- [Github Flow][github-flow] for branching/merging strategy.
- [conventional commits][conventional-commits] for commit formatting.
- [release-please][release-please] for automating releases.
  - Automatically generates pull request that can be merged when a release is ready.
  - Automatically generates change logs.
  - Automatically determines the [semantic version][sem-ver].
  - Requires [conventional commits][conventional-commits].
  - Requires linear commit history (squash or rebase merges, see note).
- [semantic versioning][sem-ver] for tracking code versions.

> [release-please][release-please] generates change logs by looking at the conventional commit messages that have occurred between the head of `main` and the last release. It is a possible for a merge commit to add commits older than the last release which can make the automation miss commits.

### Rules

1. There will be a single long term branch called `main`.
2. Work will typically be done in two types of short-lived branches:
   - `feat/feature-branch` for feature work, can contain fixes as well.
   - `fix/fix-branch` for fixes that need to be applied to main quickly.
3. All commits should follow the [conventional commits][conventional-commits] guidelines.
4. All merges will be done via pull requests.
5. Linear history **must** be maintained either by rebasing `main` onto feature branches or by squash merges.

### Typical Workflow

1. Create new branch from `main` with a name of `feat/my-cool-feature` for example.
2. Make commits to the branch.
   - `feat: my cool feature`
   - `docs: updated readme to document cool feature`
3. Rebase `main` onto feature branch.
4. Create pull request.
5. Review and merge pull request into main.
6. Delete feature branch.
7. Merge the pull request generated by [release-please][release-please] to create a new release.

## <a name="husky-git-hooks"></a> Husky Git Hooks

[Husky][husky] is a tool for managing [git hooks][git-hooks]. Git hooks are helpful for enforcing coding standards and maintaining high quality code.

- prettier for js
- white space
- markdown formatter
- linter for js

## Other topics

- unit testing
- CI on pull requests
- deployment automation (manually)
- secrets
- local testing environment
- dockerize everything eventually

[husky]: https://typicode.github.io/husky/#/
[git-hooks]: https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks
[github-flow]: https://docs.github.com/en/get-started/quickstart/github-flow
[conventional-commits]: https://www.conventionalcommits.org/en/v1.0.0/
[release-please]: https://github.com/google-github-actions/release-please-action
[sem-ver]: https://semver.org/
